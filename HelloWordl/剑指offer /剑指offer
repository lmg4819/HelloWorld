
数组
1.找出数组中重复的元素
2.不修改数组找出重复的数字
3.二维数组中的查找

字符串
1.请实现一个函数，把字符串中的每个空格替换成“%20”
在合并两个数组（包括字符串）时，如果从前往后复制每个数字则需要重复移动数字多次，
那么我们可以考虑从后向前复制，这样就能较少移动的次数，从而提高效率。

链表
1.从尾到头打印链表
递归本质上就是一个栈结构


树
1.重建二叉树
2.二叉树的下一个节点
二叉搜索树：左子节点总是小于或等于根节点，右子节点总是大于或等于根节点
堆：大顶堆和小顶堆，在最大堆中跟节点的值最大，在小顶堆中根节点的值最小
红黑树：是把树中的节点定义为红黑两种颜色，并通过规则确保从根节点到叶子节点的
最长路径的长度不超过最短路径的两倍

/*
前序遍历：{1    2 4 7    3 5 6 8}
中序遍历：{4 7 2   1    5 3 8 6}
1
2        3

4         5     6

7         8
*/


栈和队列
1.用两个栈实现队列
2.用两个队列实现栈


递归和循环
1.求斐波那契数列的第n项
2.青蛙跳台阶问题
一直青蛙一次可以跳上一级，也可以跳上两级台阶。求该青蛙跳上一个n级的台阶以供有多少种跳法


查找和排序
1.旋转数组的最小数字

要求在排序的数组或者部分排序的数组都可以用二分查找


回溯法
1.矩阵中的路径
2.机器人的活动路径

通常回溯算法适合用递归实现代码


动态规划与贪婪算法
1.剪绳子
2  1 1
3  2 1
4  2 2
5  3 2
6  3 3
7  3 4

n  n/2 n-n/2


位运算
1.二进制中1的个数

与 0 & 0 = 0 ， 0 & 1 = 0 ， 1 & 0 = 0 ， 1 & 1 = 1
或 0 | 0 = 0 ， 0 | 1 = 1 ， 1 | 0 = 1 ， 1 | 1 = 1
异或 0 ^ 0 = 0 ， 0 ^ 1 = 1 ， 1 ^ 0 = 1 ， 1 ^ 1 = 0
左移 00001010 << 2 = 00101000  10001010 << 3 = 01010000
右移 00001010 >> 2 = 00000010  10001010 >> 3 = 11110001



1.函数的整数次方
2.打印从1到最大的n位数
3.删除链表的节点
4.删除链表中重复的节点
5.正则表达式匹配
6.表示数值的字符串
7.调整数组顺序使奇数位于偶数前面
8.链表中倒数第K个节点
9.反转链表
10.合并两个排序的链表
11.树的子结构

12.二叉树的镜像
请完成一个函数，输入一颗二叉树，该函数输出它的镜像。二叉树节点的定义如下：
struct BinaryTreeNode{
int m_nValue;
BinaryTreeCode *m_pleft;
BinaryTreeNode *m_pright;
};


13.对称的二叉树
请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和他的镜像一样，那么它是对称的


14.顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序一次打印出每一个数字。例如，如果输入一下矩阵
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
打印出1 2 3 4 8 12 16 15 14 13 9 5 6 7 10 11

15.包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min，
push及pop的时间复杂度都是O（1）


16.栈的压入，弹出序列

17.从上到下打印二叉树

18.之字形打印二叉树

19.字符串的排列
输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串abc，则打印出由字符a，b，c
所能排列出来的所有字符串abc,acb,bac,bca,cab,cba


20.数组中出现次数超过一半的数字
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}，由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2.


21.最小的K个数
输入n个整数，找出其中最小的k个数，例如，输入4，5，1，6，2，7，3，8这8个数字，则最小的四个数字是1，2，3，4
1.0(nlogn)   排序
2.0(n)       Partition算法，如果基于数组的第k个数字来调整，修改了输入的数组，不适用于海量数据
3.0(nlogk)   堆或者红黑树算法 不修改数组，适用于海量数据


22.数据流中的中位数
如何得到一个数据流中的中位数，如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值
1.未排序的数组，插入数字的时间复杂度是0（1），找出中位数的时间复杂度是0（n）
2.排序的数组，插入数字的时间复杂度是0（n），找出中位数的时间复杂度是0（1）
3.排序的链表，插入数字的时间复杂度是0（n），找出中位数的时间复杂度是0（1）
4.平衡二叉树（AVL树）
5.最大堆和最小堆，左边

23.连续子数组的最大和
输入一个连续数组，数组中有证书也有负数。数组中的一个或连续多个证书组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为0(n)
-1 1 -1 1 -1 -1 -1 1 1 -1
1.动态规划法


24.1~n整数中1出现的次数
输入一个整数n，求1到n这n个整数的十进制表示中1出现的次数。例如输入12，1~12这些整数中，包含1的数字有1，10，11，12，1一共出现了5次
1-9   1
10-19 1*10+1
20-29 1
30-19 1


25.数字序列中某一位的数字
数字一0123456789101112131415的格式序列化到一个字符序列中，在这个序列中，第五位（从0开始计数）是5，第13位是1，第19位是4，等等，请写一个函数，求任意第n位对应的数字
n
1001 811 3 270+1 370 7
1 10 10
2 90 180
3 900 2700
4 9000 36000

26.把数组排成最小的数
输入一个正整数数组，把数组中的所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组（3，32，321），则打印出这3个数字能排成的最小数字321323


27.把数字翻译成字符串
给出一个数字，我们按照以下规则把它翻译成字符串：0翻译成‘a’,1翻译成‘b’，11翻译成‘l’。25翻译成‘z’,一个数字可能有多个翻译。例如12258有5中不同的翻译，分别是‘bccfi’,'bwfi','bczi','mcfi','mzi'.请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法

12258

8  1 f(5) = 1
58  1 f(4) = 1
2 58  25 8 f(5)+f(4) = 2
2 258 22 58 f(3)+f(4) = 3
12258 1 2258 12 258 f(2)+f(1) = 5


28.礼物的最大价值
在一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0），你可以从棋盘的左上角
开始拿格子里的礼物，并每次向下或者向右移动一格，知道到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物
1   10   3   8
12  1    9   6
5   7    4   11
3   7    16  5

29.最长不含重复字符的字符串
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度，假设子字符串中只包含‘a’-'z'的字符，例如，在字符串“arabcacfr”中，最长的不含重复字符的子字符串是acfr长度为4

arabcacfr
a   a
ar  ar
ara ra或ar
arab rab
arabc rabc
arabca rabc
arabcac rabc
arabcacf rabc
arabcacfr rabc或acfr


30.丑数
我们把只包含因子2，3，5的数称为丑数，求按从小到大的顺序的第1500个丑数，例如，6，8都是丑数，
14不是丑数，因为他包含因子7，习惯上我们把1当成第一个丑数
1.逐个判断每个整数是不是丑数的解法，直观但不够高效
2.创建数组保存已经找到的丑数，用空间换时间的算法
[1,2,3,4,5,6,8,9,10]
1 2 3 6
1 2 4 6 10
1 2 4










