
数组
1.找出数组中重复的元素
2.不修改数组找出重复的数字
3.二维数组中的查找

字符串
1.请实现一个函数，把字符串中的每个空格替换成“%20”
在合并两个数组（包括字符串）时，如果从前往后复制每个数字则需要重复移动数字多次，
那么我们可以考虑从后向前复制，这样就能较少移动的次数，从而提高效率。

链表
1.从尾到头打印链表
递归本质上就是一个栈结构


树
1.重建二叉树
2.二叉树的下一个节点
二叉搜索树：左子节点总是小于或等于根节点，右子节点总是大于或等于根节点
堆：大顶堆和小顶堆，在最大堆中跟节点的值最大，在小顶堆中根节点的值最小
红黑树：是把树中的节点定义为红黑两种颜色，并通过规则确保从根节点到叶子节点的
最长路径的长度不超过最短路径的两倍

/*
前序遍历：{1    2 4 7    3 5 6 8}
中序遍历：{4 7 2   1    5 3 8 6}
1
2        3

4         5     6

7         8
*/


栈和队列
1.用两个栈实现队列
2.用两个队列实现栈


递归和循环
1.求斐波那契数列的第n项
2.青蛙跳台阶问题
一直青蛙一次可以跳上一级，也可以跳上两级台阶。求该青蛙跳上一个n级的台阶以供有多少种跳法


查找和排序
1.旋转数组的最小数字

要求在排序的数组或者部分排序的数组都可以用二分查找


回溯法
1.矩阵中的路径
2.机器人的活动路径

通常回溯算法适合用递归实现代码


动态规划与贪婪算法
1.剪绳子
2  1 1
3  2 1
4  2 2
5  3 2
6  3 3
7  3 4

n  n/2 n-n/2


位运算
1.二进制中1的个数

与 0 & 0 = 0 ， 0 & 1 = 0 ， 1 & 0 = 0 ， 1 & 1 = 1
或 0 | 0 = 0 ， 0 | 1 = 1 ， 1 | 0 = 1 ， 1 | 1 = 1
异或 0 ^ 0 = 0 ， 0 ^ 1 = 1 ， 1 ^ 0 = 1 ， 1 ^ 1 = 0
左移 00001010 << 2 = 00101000  10001010 << 3 = 01010000
右移 00001010 >> 2 = 00000010  10001010 >> 3 = 11110001



1.函数的整数次方
2.打印从1到最大的n位数
3.删除链表的节点
4.删除链表中重复的节点
5.正则表达式匹配
6.表示数值的字符串
7.调整数组顺序使奇数位于偶数前面
8.链表中倒数第K个节点
9.反转链表
10.合并两个排序的链表
11.树的子结构

12.二叉树的镜像
请完成一个函数，输入一颗二叉树，该函数输出它的镜像。二叉树节点的定义如下：
struct BinaryTreeNode{
int m_nValue;
BinaryTreeCode *m_pleft;
BinaryTreeNode *m_pright;
};


13.对称的二叉树
请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和他的镜像一样，那么它是对称的


14.顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序一次打印出每一个数字。例如，如果输入一下矩阵
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
打印出1 2 3 4 8 12 16 15 14 13 9 5 6 7 10 11

15.包含min函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min，
push及pop的时间复杂度都是O（1）


16.栈的压入，弹出序列

17.从上到下打印二叉树

18.之字形打印二叉树

19.字符串的排列
输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串abc，则打印出由字符a，b，c
所能排列出来的所有字符串abc,acb,bac,bca,cab,cba
