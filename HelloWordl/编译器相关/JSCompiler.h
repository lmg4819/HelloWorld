//
//  JSCompiler.h
//  HelloWordl
//
//  Created by lmg on 2019/4/30.
//  Copyright © 2019 lmg. All rights reserved.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface JSCompiler : NSObject
/*
 1.在使用三方库时，我们常常在Xcode的Building Settings下Other Link Flags里面加入-ObjC编制。
 原因：UNIX的标准静态库实现和Objective-C的动态语言特性之间有一些冲突，Objective-C没有为每个函数定义链接符号，它只为每个类创建链接符号，这样当在一个静态库中使用类别来扩展已有类时，连接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你引用类别中的方法时，出现“selector not recognized”，也就是找不到方法定义的错误。为了解决这个问题，引入了-ObjC标志，它的作用是将静态库中所有的类别都加载进来。在64的Mac系统或者iOS系统下,链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是通过-all_load或者-force_load标志，他们的作用都是加载静态库中所有文件，不过-all_load作用于所有的库，而-force_load后面必须要指定具体的文件加载的位置。
 
 OC源文件的编译过程：
 1.输入源文件
 2.预处理器（词法分析）：源代码会被拆分为多个记号，每个记号都是一个独立的语言元素，如关键字，标识符，操作符和在其本身语法环境中的符号名。
 3.语法分析器（语法分析）：会检查正确语法的记号，并检查他们所构成表达式的合法性。这项任务的目的是通过记号创建抽象语法树（AST）或层次分析树
 4.AST
 5.生成代码和优化阶段：AST用于生成输出语言代码，输出语言可能是机器语言，也可能是中间语言表示（IR），优化后，代码的功能不会改变，但性能更好，体积更小。
 6.汇编程序：会接收到上一阶段生成的代码，并将它们转换为目标平台上可执行的机器代码
 7.链接程序：汇编程序输出的一段或多段代码会被合并为一个独立的可执行程序
 8.输出可执行的二进制文件
 
 预处理器是在语法分析之前的词法分析这个阶段发挥作用的。它们会根据一系列预处理器的规则，使用其他字符传序列替换源文件中的某些字符序列。
 预处理器会在编译前处理源文件，但预处理器不能识别OC代码，预处理器是一种不同于OC的独立编程语言，使用该语言对源文件进行转换的主要目的是包括源文件的内容，进行条件编译和宏展开。
 宏（尤其是函数型宏）拥有强大的功能，但也具有非常大的危险性。以不正确的方式使用宏会导致嵌套错误，运算优先规则和重复性副作用等问题，因为，对复杂宏依赖程度较大的代码会使维护变得困难。
 你应该在自己编写的OC代码中尽量少使用宏
 
 预处理器指令及其作用
 头文件包含（#import #include）
 条件编译（#if，#elif,#else,#endif,#ifdef和#ifndef）
 诊断（#error,#warning,#line）
 #pragma指令
 
 
 当使用双引号（""）封装头文件的名称时，编译器会先从存储源文件的目录中搜索被包含的头文件。如果没有找到，编译器会在默认目录中搜索头文件，默认目录是预先配置的用于搜索系统标准头文件的目录。
 当使用尖括号（<>）封装头文件的名称时，编译器会在默认目录中搜索被包含的头文件。
 按照惯例，应使用尖括号封装标准头文件，因为它们通常会被保存在默认目录中，而其他头文件会使用双引号封装
 #import和#include都可以通过两种方式封装头文件的名称。与#include的区别是，它可以确保头文件仅在源文件中包含一次，因而能够防止递归包含
 为了防止递归包含，有两种方法
 1.使用#inport
 2.使用包含警卫#ifndef #define
 
 宏是指有名称的代码段。预处理器无法识别OC语句，它仅是将宏名替换为相应的值和代码。
 
 */
@end

NS_ASSUME_NONNULL_END
