界面卡顿是由哪些原因造成的
1.死锁          主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。
2.抢锁          主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。
3.主线程大量I/O  主线程为了方便直接写入大量数据，会导致界面卡顿
4.主线程大量计算  算法不合理，导致主线程某个函数占用大量 CPU。
5.大量的UI绘制   复杂的UI，图文混排等，带来大量的UI绘制


怎么定位问题：
1.死锁一般会伴随crash，可以通过crash report来分析
2.抢锁不好办，将锁等待时间打出来用处不大，我们还需要知道是谁占了锁。
3.大量 IO 可以在函数开始结束打点，将占用时间打到日志中。
4.大量计算同理可以将耗时打到日志中。
5.大量 UI 绘制一般是必现，还好办；如果是偶现的话，想加日志点都没地方，因为是慢在系统函数里面。


思路就是起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈dump下来

一般卡顿有三个情形：
1.FPS降低
2.CPU占用率较高
3.主线程RunLoop执行了很久

实际上的两个准则：
1.CPU占用超过了100%
2.主线程RunLoop执行超过了2s



