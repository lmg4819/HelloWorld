

5.TCP的三次握手
1。客服端发送自己的syn包到服务器，此时处于syn_send状态
2。服务器收到客户端的syn包，必须确认客户的syn同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态。
3。客户端收到服务器的syn+ack包后，想服务器发送确认包，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成第三次握手

6.iOS中的所有架构
模拟器：
i386     4s-5
x86_64   5s---最新
真机：
armv7    3gs--4S
armv7s   5/5c
arm64    5s---最新







16.runtime如何通过selector来找到的IMP地址？





25.delegate的作用是什么
两个对象之间传递数据和参数
解耦，拆分业务逻辑


26.为什么说OC是动态语言
1.动态类型，即运行时再决定对象的类型
2.动态绑定，消息机制，调用方法的对象类型和所调用的方法都是运行时才决定的
3.动态加载
4.多态，不同对象以自己的方式响应相同的消息的能力叫做多态


27.什么是推送通知
本地推送：程序内部弹出通知到用户设备
远程推送：由苹果APNS服务器推送通知到设备


28.什么是多态
父类指针指向子类对象

29.什么是谓词
可以以一定条件来过滤数组，字典等集合数据，也能用在CoreData的数据查询中


31.线程间怎么通信
[self performSelector],NSOperationQueue,GCD

32.网络图片处理问题中怎么解决一个相同的网络，地址重复请求的问题
利用字典，以URL为key，下载操作为value



36.Method Swizzling需要注意的几个点
1.避免交换父类方法
2.交换方法应该在+load方法
3.交换方法应该放在dispatch_once中执行：防止手动调用+load方法而导致反复的被交换
4.交换的父类方法应该添加自定义前缀，避免冲突
5.交换的分类方法应调用原实现

37.什么情况下会发生内存泄露和内存溢出
分配的内存在该回收的时候无法回收，就是内存泄露，比如申请了一个int，但给它存了long才能存下的数，那就是内存溢出。


38.[NSArray arrayWithObject:<id>]这个方法添加对象后，需要对这个数组做释放操作吗
不需要，这个对象被放到自动释放池中。


39.自动释放池底层怎么实现
自动释放池以栈的形式实现，当你创建一个新的自动释放池时，它将被添加到栈顶，当一个对象收到autoRelease消息时，它被添加到当前当前线程的处于栈顶的自动释放池中，当自动释放池被回收时，他们从栈中被删除，并且会给池子里面多有的对象都会做一次release消息


40.自动释放池是什么，如何工作
当你想一个对象发送autorelease消息时，Cocoa就会将该对象的一个引用放入最新的自动释放池，它仍然是个正常的对象，因此自动释放池作用域内的其他对象可以向它发送消息。当程序执行到作用域结束的时候，自动释放池就会被释放，池中的所有对象也会被释放

41.如何ARC和MRR混编
-fobjc-arc
-fno-objc-arc


42.KVO内部实现原理
KVO是基于Runtime实现的，当一个对象被注册为被观察者的时候，这个类A在运行时会动态生成一个派生类KVONotifying_A，这个类继承于A，并且A的isa指针会指向这个类，通过修改被观察属性的set方法，调用willChangeValueFor和didChangeValueForKey来触发回调


43.数据库中的左连接和右连接的区别
左连接：只要左边表中有记录，数据就能检索出来，而右边有的记录必须在左边表中有才能被检索出来
右连接：只要右边表中有记录，就能被查询出来

新建两张表：t_left_tab和t_right_tab，将t_left_tab作为左边表,t_right_tab作为右边表
左连接：SELECT * FROM t_left_tab a LEFT JOIN t_right_tab b ON a.'id'=b.'id';
右连接：SELECT * FROM t_right_tab a LEFT JOIN t_left_tab b ON a.'id'=b.'id';
查询最大条数：SELECT * FROM t_left_tab a LEFT JOIN t_right_tab b ON 1=1;

结论：数据库左连接和右连接的区别：主表不一样，通过左连接和右连接，最小条数为3（记录条数最小的记录数），最大条数为12（a*b）



44.UIView不能接受触摸事件的三种情况
userInteractionEnabled = NO,UIImageView默认不能接受触摸userInteractionEnabled=NO，
hidden = Yes
alpha < 0.01


47.APP需要请求大量的数据，给服务器发送请求，但是服务器卡住了如何操作
1.设置请求超时
2.提醒用户超时
3.根据用户操作再次请求数据


48.RunLoop定时源和输入源
1.你创建的程序不需要显式的创建RunLoop，每个线程，包括程序的主线程都有与之对应的RunLoop对象，主线程会自动创建并运行RunLoop

@synthesize:关键字，可以使编译器自动生成属性定义
@dynamic:关键字，阻止编译器自动生成访问器方法
一般而言，我们可以通过set/get方法和点语法这两种机制来访问属性
如果与属性关联的对象还没有完全创建好，就不要使用这些机制，而应该使用支持属性的实例变量，这意味着在init方法和dealloc方法中直接访问实例变量。

协议使OC支持多继承规范的概念。在协议中声明的方法和属性可以由任何类实现使用协议可以在无继承关系的类中实现通用行为。


分类可以在不尽兴子类化的情况下，为已经存在的类添加功能。分类中的方法会成为类的组成部门，并且会被子类继承。分类的作用：
1.扩展其他人定义的类
2.替代子类
3.将类的实现代码分发到多个源文件中


扩展可以视为匿名的分类，扩展声明的方法必须在类的主实现块中实现，扩展还可以声明实例变量和属性。



根类（基类）定义了类层次结构中该类下方所有类的公有接口和行为。Foundation框架提供了两个根类，NSProxy,NSObject.
NSProxy是专门用于实现代理的类。
NSObject是大多数OC类层次结构的根类。
这两个根类都采用NSObject协议，该协议声明了所有OC对象的公用方法。

为了避免initialize方法vein调用两次的情况，应使用验证调用者为目标类而非父类的逻辑。
+(void)initialize
{
if (self == [BasicGreeter class]) {
//初始化逻辑
}
}

NSProxy声明了必须由子类实现的两个方法：
-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel;
-(void)forwardInvocation:(NSInvocation *)invocation;
此外，NSProxy的子类必须声明并且实现至少一个init方法


load加载和initialize方法的区别：
1.load方法会在initialize方法的调用操作之前，类被加载之后立即被调用。实际上，对于以静态方式链接的类（可执行程序的组成部分），调用load方法的操作在调用main（）函数的操作之前。如果load方法是在可选包中的类实现的，那么当该包以动态方式被加载时load方法就会执行。当该方法被调用时，程序的自动释放池通常还不存在，其他类可能还没有加载。
2.load方法可以由类实现也可以由分类实现。事实上，一个类中的所有分类都可以实现其本身的load方法，initialize方法永远不能在分类实现。
3.load方法在实现的前提下，一定会被调用且仅调用一次。initializet如果类没有被使用，那么该方法就不会被调用。


/*
http://mobile.hktsc.cc/services/list?appPage=serviceList&brandId=1

URL的组成
scheme/protocol   :传输协议,http,https
credentials(可选)  :user:password@
hostname          : 资源服务器的主机地址
port（可选）        :端口号，指定客户端应该连接哪个端口，如果忽略则使用默认端口。有时候处于安全或其他考虑，
可以在服务器上对端口进行重定义，即采用非标准端口号，此时，URL中就不能省略端口这一项。
path               :绝对路径，由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或者文件地址。
query(可选)         :查询，URL最后部分是查询字符串，这个值是从path用？隔开的，多个参数每个用&分割。查询字符串不能包含
回车空格换行字符。
fragment           :信息片段，字符串。用于指定网络资源中的片段。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。


NSURL *url = [NSURL URLWithString:@"http://www.baidu.com/services/list?appPage=serviceList&brandId=1"];
NSLog(@"scheme:%@------user:%@-----password:%@-----host:%@-----port:%@------path:%@-----query:%@",url.scheme,url.user,url.password,url.host,url.port,url.path,url.query);
打印结果：
scheme:http------user:(null)-----password:(null)-----host:www.baidu.com-----port:(null)------path:/services/list-----query:appPage=serviceList&brandId=1
*/


/*
Model -----  View   ---- ViewController

Model ----- View + ViewController

Model ----- View + ViewController + ViewModel(将model转换成view可以展示的东西)
优势：能减少ViewController的复杂性并使得表示逻辑更易于测试
1.MVVM可以兼容你的MVC代码
2.MVVM增加你的代码的可测试性
3.MVVM配合一个绑定机制效果更好


NSNumber实例为标量值（整数型，浮点型和布尔型值）提供了对象封装器。
NSNumber常量对象是通过标量值而不是表达式创建的。还应注意，NSNumber常量实在运行程序是被求值的，因此他们不是编译时常数，因而无法用于初始化静态变量和全局变量。下面的语句无法编译。


*/

/*
static修饰局部变量
static修饰局部变量，改变变量的存储方式，使变量成为局部的静态变量。
即编译时就为变量分配内存，直到程序退出才释放存储变量。这样，使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用。
static修饰外部变量
外部变量指在代码块{}之外定义的变量，它缺醒为静态变量，编译时分配内存，程序结束时才释放内存单元。同时，其作用域很广，整个文件都有效，甚至别的文件也能引用它。为了限制某些局部变量的作用域，使其指在本文件中有效，而不能被其他文件引用，可以用static关键字对其作出声明。

*/


/*
id类型是所有OC类型对象，用于存储对任何OC对象的引用
id仅是一个指向objc_ocject标识符的C语言结构的指针


typedef struct objc_object{
Class isa;
}*id;


typedef struct objc_class *Class;
Class数据类型是一种指针，这种指针指向带objc_class标识符的不透明类型。
当编译器解析OC对象的代码时，会生成创建运行时对象类型的代码，即objc_object类型。


struct objc_object{
Class isa;
}
objc_object类型含有一个变量，该变量的类型是Class，名称为isa；换言之，它是一个指向objc_class类型变量的指针。

*/


/*
OC保留字
变量范围：
块，在语句块中声明的变量拥有块范围。
文件，拥有文件范围的变量只能在声明它的文件中可见于被访问。
函数，在函数/方法中声明的变量拥有函数范围。


*/


/*
键值编码（KVC）可以通过名称（key）间接访问对象的属性，而无须使用访问方法支持实例变量。
键值观察（KVO）能够使对象在其他对象的属性发生更改时获得通知。

与标准的属性访问方法相比，KVC有什么好处：
1.基于配置的属性访问。通过KVC可以使用由参数驱动的通用API访问属性。
2.降低耦合性。通过KVC访问属性可以降低各个软件组件之间的耦合性，从而提高软件的可维护性。
3.简化代码。通过KVC可以减少代码量。

非正式协议NSKeyValueCoding

KVC通过依赖于属性方法命名约定的一系列搜索模式，以setValue:name forKey为例
1.先搜索setName:的访问方法
2.寻找名称匹配_name,_isName,name,isName的实例变量。
3.如果找到了匹配的访问方法或者实例变量，setValue:name forKey方法就会被用于设置值。如有必要，该值会被封装。
4.如果没有找到适当的访问方法或者实例变量，接受对象的setValue:forUndefinedKey:就会被调用.

键值检验：
validateValue检验设置的对象值是否合法。

键值编码的集合操作符：

键值观察（KVO）是一种通知机制，它使对象能够在其他对象的属性发生更改时获得通知。是对观察者设计模式的一种实现

键值编码要点：
1.通过键值编码可以通过名称（Key）间接访问和操作对象的属性，而无需通过访问方法或者属性的支持实例变量。
2.通过键值编码可以使用能够在程序运行时变化的字符串访问属性，这位访问和操作对象状态提供了
更为动态而灵活的方式。其主要优点包括降低耦合度，能够执行基于配置的属性访问操作和简化代码。
3.键值编码使用键和键路径访问属性。键是用于表示指定属性的字符串。键路径指示了对象的属性序列，用于标识指定属性的遍历路径。KVC API支持对一个对象中的一个或多个属性进行访问。属性的类型可以为基元，C语言数据结构和对象类型（包括集合）,Objective-C会使用相应的对象类型，自动封装和解封基元和C语言结构。
4.非正式协议NSKeyValueCoding定义了通过名称/键间接访问对象的机制。该协议声明了键值编码API，以及构成这些API的类，实例方法和常量值。使用这些方法可以获取和设置属性值。检验属性值，以及为了获取属性值改变键值编码方法的默认行为。
5.键值编码使用了一种机制。该机制将键与相应的属性访问方法或属性支持变量对应起来。这种机制提供了一系列依赖于属性访问方法命名约定的标准搜索模式。
6.键值编码还有检验属性值的基础设施。KVC检验机制由一系列API和自定义属性检验方法标准约定构成。可以直接调用KVC检验方法，也可以间接调用KVC检验方法。
7.使用键值编码集合操作符，可以通过键路径点表达式对集合元素执行操作。
8.通过键值观察模式可以使对象在其他的对象属性发生变化时获得通知，时机上，它是对观察者设计模式的实现，并且非常多的软件库和框架都实现了它。时机上，它使MVC设计模式的关键组件，而后者是Cocoa和Cocoa Touch框架的核心组件。键值观察以键值编码为基础。
9.键值观察的优点非常多，其中包括分割观察者和被观察者，提供框架级支持和功能齐全的API集合。
10.自动属性更改通知功能是由NSObject类中默认实现的KVO代码实现的，手动属性更该通知功能为属性更改通知的发送操作提供了更精细的控制，去除了不必要的操作（如新的属性值与旧的属性值相同时），还能够对通知进行分组。
11.





*/

/*

*/





/*

*/


